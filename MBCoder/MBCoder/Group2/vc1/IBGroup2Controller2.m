//
//  IBGroup2ViewController2.m
//  IBCoder1
//
//  Created by BowenCoder on 2019/5/10.
//  Copyright © 2019 BowenCoder. All rights reserved.
//

#import "IBGroup2Controller2.h"

@interface IBGroup2Controller2 ()

@end

@implementation IBGroup2Controller2

/*
 一、地址空间存储区域
 1、代码段(.text)，也称文本段(Text Segment)，
 存放着程序的机器码和只读数据，可执行指令就是从这里取得的。
 如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。
 这个段在内存中一般被标记为只读，任何对该区的写操作都会导致段错误（Segmentation Fault）。
 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。
 
 2、数据段，包括已初始化的数据段(.data)和未初始化的数据段（.bss），
 前者用来存放保存全局的和静态的已初始化变量，
 后者用来保存全局的和静态的未初始化变量。数据段在编译时分配。
 
 3、堆栈段分为堆和栈：
 堆（Heap）：用来存储程序运行时分配的变量。
 堆的大小并不固定，可动态扩张或缩减。其分配由malloc()、new()等这类实时内存分配函数来实现。
 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；
 当利用free()等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减），
 堆的内存释放由应用程序去控制通常一个new()就要对应一个delete()，
 
 4、栈（Stack）是一种用来存储函数调用时的临时信息的结构，如函数调用所传递的参数、函数的返回地址、函数的局部变量等。
 在程序运行时由编译器在需要的时候分配，在不需要的时候自动清除。
 栈的特性: 最后一个放入栈中的物体总是被最先拿出来，这个特性通常称为先进后出(FILO)队列。
 栈的基本操作：
 PUSH操作：向栈中添加数据，称为压栈，数据将放置在栈顶；
 POP操作：POP操作相反，在栈顶部移去一个元素，并将栈的大小减一，称为弹栈
 
 
 二、堆和栈的区别：
 1.分配和管理方式不同 ：
 堆是动态分配的，其空间的分配和释放都由程序员控制。
 栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。
 静态分配由编译器完成，比如局部变量的分配。
 动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。
 
 2.产生碎片不同
 对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。
 对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。
 
 3.生长方向不同
 堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。
 栈的生长方向与之相反，是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。
 
 三、结构体内存
 结构体内存对齐规则
 1、结构体变量的首地址能够被其最宽基本类型成员的大小所整除。
 原因：结构体在考虑最宽成员时会将包含于此的结构体成员"打散"，被“打散”后里面也全部是基本类型。

 2、结构体每个成员相对于结构体首地址的偏移量(offset)都是成员大小的整数倍
    如有需要编译器会在成员之间加上填充字节(internal adding)。
 
 3、结构体的总大小为结构体最宽基本类型成员大小的整数倍，
    如有需要编译器会在成员末尾加上填充字节
 
 四、内存字节对齐
 选择对齐模式会以牺牲空间的代价提升时间效率.
 64位8字节对齐：http://stackoverflow.com/questions/21219130/is-8-byte-alignment-for-double-type-necessary
 The interface to memory might be eight bytes wide and only able to access memory at multiples of eight bytes.
 Loading an unaligned eight-byte double then requires two reads on the bus. Stores are worse, because an
 aligned eight-byte store can simply write eight bytes to memory, but an unaligned eight-byte store must
 read two eight-byte pieces, merge the new data with the old data, and write two eight-byte pieces.
 
 32位4字节对齐：
 因为地址总线的关系，有2根总线不参与寻址，导致只能获取到4的整数倍的地址，所以默认是4字节对齐
 
 五、总线
 数据总线
 （1）是CPU与内存或其他器件之间的数据传送的通道。
 （2）数据总线的宽度决定了CPU和外界的数据传送速度。
 （3）每条传输线一次只能传输1位二进制数据。eg: 8根数据线一次可传送一个8位二进制数据(即一个字节)。
 （4）数据总线是数据线数量之和。
 
 地址总线
 （1）CPU是通过地址总线来指定存储单元的。
 （2）地址总线决定了cpu所能访问的最大内存空间的大小。eg: 10根地址线能访问的最大的内存为1024位二进制数据(1B)
 （3）地址总线是地址线数量之和。
 
 控制总线
 （1）CPU通过控制总线对外部器件进行控制。
 （2）控制总线的宽度决定了CPU对外部器件的控制能力。
 （3）控制总线是控制线数量之和。
 
 六、编译程序的工作过程可划分五个阶段：
 1、词法分析：从左到右一个字符一个字符的读入源程序，对构成源程序的字符串进行扫描
            和分解，从而识别出一个个单词（也称单词符号或简称符号）。( a+++b为什么是a++ +b而不是a+ ++b)
 2、语法分析：在词法分析的基础上将单词序列分解成各类语法短语，如“程序”，“语句”，“表达式”等等。
 3、语义分析和中间代码生成：语义分析是在语法分析程序确定出语法短语后，审查有无语义
                        错误，并为代码生成阶段收集类型信息。完成语法分析和语义
                        处理工作后，编译程序将源程序变成一种内部表示形式，这种
                        内部表示形式叫做中间语言或称中间代码，它是一种结构简单、
                        含义明确的记号系统。
 4、代码优化：为了使生成的目标代码更为高效，可以对产生的中间代码进行变换或进行改造。
 5、目标代码生成：把中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。
 
七、SS1，SS2原则
 1、side effects：（副作用）
    副作用就是程序中的变量产生的改变，赋值，自增，自减表达式，函数调用表达式
 2、sequence points：（序列点）
    序列点是一种逻辑意义的点，逻辑点前的副作用都在这时生效
    C标准中定义的序列点总共有三类：
    a、第一类是完全表达式
    b、第二类是||和&&和;和?:(三目运算符的条件判断)
    c、第三类是函数调用
 3、SS1
 标准中规定了在前一个序列点前的副作用都会在前一个序列点后完成，
 但是标准没有规定两个序列点之间的副作用生效的顺序，不同的C语言实现的顺序可能不同。
 请注意这一点，这是所有问题产生的根本原因。如果两个序列点之间有超过两个的副作用作用在同一个实体上，
 这样不同的编译器产生的结果就不同，这种情况在标准中称为unspecified。
 所以在实际应用中应该避免这种情况的出现，我把这一个原则称为为SS1。
 例如：printf("%d",++a+a++);
 4、SS2
 在两个序列点之间，如果出现对一个实体的多次引用，并且只有一次会对该实体产生副作用（SS1），
 那么所有的这些引用都必须用来产生这个副作用 ，我把这一个原则称为SS2。
 例如：printf("%d %d", a, a = a*2);arry[i] = i++;
 
 总之，谨记，在实际应用中应该遵守“一条语句只做一件事的原则”。
 
 八、优先级，结合方向，执行顺序
 C语言中组成程序的基本单位是表达式（expression），表达式是指用操作符（operator）和操作数（operand）连接起来的式子。
 C标准给出了最基本的操作符，通过这些操作符可以组成简单表达式，同样也可以通过复合产生复杂表达式。
 优先级和结合方向只是解决操作符和操作数如何组合起来的。
 
 1、优先级，结合方向
 优先级的定义并不是，哪个操作符更先执行，而是那个操作符可以更先于旁边的操作数结合
 但是由于优先度和结合方向往往决定了一个操作符的结果是另外一个操作符的操作数，
 那么由于操作数的得到一定先于操作符，所以就间接的安排了很多的执行顺序。
 
 2、执行顺序
 C语言中只对(逗号,)、(逻辑与&&)、(逻辑或||)、(条件表达式)规定了执行顺序，对于逻辑表达式方向是从左向右执行的，
 其他的都不规定执行顺序。
 只要遵循SS1，SS2。那基本上一个表达式中的先后执行顺序基本是不会导致最终结果的不同的，
 而不定死先后顺序，编译器就可以充分的在上面做文章，这样就可以做到很好的性能优化。
 所以，编程的时候，最后要此那种“一句话干一件事”的风格，不要追求一个“复杂的丰富的表达式”。
 
 3、优先级、结合方向没有做哪些事？
 仅仅依靠优先级和结合方向是无法确定一个复合表达式中对各个子表达式的求值顺序。标准中对于这点的规定是：
 两个相邻的操作符的执行顺序由它们的优先级决定。如果它们优先级相同，它们的执行顺序由它们的结合性决定。
 除此之外，编译器可以自由决定任何顺序对表达式进行求值，只要它不违反逗号，&&，||和？：操作符所施加的限制。
 
 
 */

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
}



@end
