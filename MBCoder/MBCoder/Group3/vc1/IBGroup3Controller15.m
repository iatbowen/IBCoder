//
//  IBGroup3Controller15.m
//  MBCoder
//
//  Created by 叶修 on 2026/2/6.
//  Copyright © 2026 inke. All rights reserved.
//

#import "IBGroup3Controller15.h"

@interface IBGroup3Controller15 ()

@end

@implementation IBGroup3Controller15

- (void)viewDidLoad {
    [super viewDidLoad];
}

@end

/*
 一、MCP（Model Context Protocol）
 旨在统一大型语言模型（LLM）与外部数据源和工具之间的通信协议
 
 1. MCP 核心架构
 MCP 遵循客户端-服务器架构（client-server），其中包含以下几个核心概念：
 - MCP 主机（MCP Hosts）：发起请求的 LLM 应用程序。
 - MCP 客户端（MCP Clients）：在主机程序内部，与 MCP server 保持 1:1 的连接。
 - MCP 服务器（MCP Servers）：为 MCP client 提供上下文、工具和 prompt 信息。
 - 本地资源（Local Resources）：本地计算机中可供 MCP server 安全访问的资源（例如文件、数据库）。
 - 远程资源（Remote Resources）：MCP server 可以连接到的远程资源（例如通过 API）。
 
 2. 通信机制
 MCP 协议支持两种主要的通信机制：基于标准输入输出的本地通信和基于SSE（Server-Sent Events）的远程通信。
 - 本地通信：通过 stdio 传输数据，适用于在同一台机器上运行的客户端和服务器之间的通信。
 - 远程通信：利用 SSE 与 HTTP 结合，实现跨网络的实时数据传输，适用于需要访问远程资源或分布式部署的场景。
 
 3. 优缺点：
 优点：
 - 标准化工具接入（统一协议）
 用一套通用规范把搜索、数据库、内部系统、脚本等暴露给模型
 
 - 解耦：模型/Agent 与工具实现分离
 工具侧做成 MCP Server，模型侧只按协议调用。
 
 缺点：
 - 只解决“连接与调用”，不解决“能力封装”:
 MCP擅长把外部工具/服务（搜索、DB）用统一协议暴露给模型调用。但它不定义“把多个工具串起来形成一个业务动作”的封装方式（例如“报销审批”“线索转商机”这种一键能力）。

 - 对“业务流程/编排”的表达弱：
 复杂任务常需要：多步决策、状态机、分支、重试、补偿、审批、人审等。MCP一般停留在单次/多次工具调用层面
 
 MCP 只解决了工具接入的问题，并没有解决工具如何被调用的问题
 

 二、Skills
 
 1. Skills 的本质是什么？
 是把完成某个任务的完整过程打包在一起：
 - 该调用哪些工具
 - 按什么顺序调用
 - 每一步的提示词怎么写
 - 遇到错误怎么处理
 所有的经验，都封装在一个 Skill 里。不只是解决了"工具能不能用"的问题，还解决了"工具怎么用好"的问题。
 
 2. 渐进式披露：破解上下文困境
 +------------------------------------------------------------------+
 |           AI Agent Skill 渐进式加载架构                             |
 +------------------------------------------------------------------+
 |
 |  MCP: 一次性加载全部
 |  v
 +------------------------------------------------------------------+
 | Layer 1: Metadata                                                |
 | 智能体启动时加载                                                    |
 | 内容: Frontmatter (YAML) - name / description / allowed_tools     |
 +------------------------------------------------------------------+
 | 任务匹配时加载
 |  v
 +------------------------------------------------------------------+
 | Layer 2: Instructions                                            |
 | 任务匹配时获取详细指导                                               |
 | 内容: SKILL.md - Workflow Steps / Examples / Best Practices       |
 +------------------------------------------------------------------+
 | 仅需时加载
 |  v
 +------------------------------------------------------------------+
 | Layer 3: Scripts & References                                    |
 | 按需加载，无上限                                                    |
 | 内容: parse_pdf.py / forms.md / data.json 等脚本与数据              |
 +------------------------------------------------------------------+
 |
 | Skills: 渐进式加载 (按需消耗)
 +------------------------------------------------------------------+
 
 3. 推荐结构
 .cursor/
 └── skills/
     └── deploy-app/
         ├── SKILL.md
         ├── scripts/
         │   ├── deploy.sh
         │   └── validate.py
         ├── references/
         │   └── REFERENCE.md
         └── assets/
             └── config-template.json
 
 4. 文件格式
 ---
 name: my-skill
 description: 简要描述此技能的功能及使用时机。
 ---

 # 我的技能

 为 Agent 提供的详细指令。

 ## 使用时机

 - 在以下情况使用此技能...
 - 此技能适用于...

 ## 指令

 - 为 Agent 提供的分步指导
 - 特定领域的约定
 - 最佳实践和模式
 - 如需向用户澄清需求,请使用提问工具
 

 三、Skills 与 MCP（模型上下文协议）
 
 MCP 的职责：提供标准化的访问接口，关注的是 AI 如何以统一方式调用外部的工具、数据和服务，本身不定义任务逻辑或执行流程
 Skills 的职责：教 Agent 如何完整处理特定工作，它将执行方法、工具调用方式以及相关知识材料，封装为一个完整的「能力扩展包」，使 Agent 具备稳定、可复用的做事方法
 Skills 安全性不如 MCP，但是使用更简单成本更低
 
 
 四、Skills vs 工作流
 
 工作流是死的，Skills 是活的。

 工作流：是静态的，第一步做什么，第二步做什么，遇到 A 情况走左边，遇到 B 情况走右边。像一条固定的流水线，灵活性较差。
 Skills：灵活变通，核心设计采用了渐进式披露（Progressive Disclosure）原则。
 LLM 每次执行任务时，会先扫一遍所有 Skills 的简介，判断哪些可能用得上，再决定要不要深入读取完整内容。占用资源极少

 
*/
