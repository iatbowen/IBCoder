//
//  IBController40.m
//  IBCoder1
//
//  Created by Bowen on 2018/7/27.
//  Copyright © 2018年 BowenCoder. All rights reserved.
//

#import "IBController40.h"
#import "ReactiveObjC.h"
@interface IBController40 ()

@end

@implementation IBController40

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    
}

@end

/*
 一、动态库和静态库的区别
 
 库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。
 
 1、iOS开发中静态库和动态库区别:
 静态库和动态库是相对编译期和运行期的：
 静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；
 动态库在程序编译时并不会被链接到目标代码中，在程序启动后用动态加载，然后再决议符号。
 
 一、核心区别
 特性               静态库（.a 或静态 Framework）       动态库（动态 Framework）
 文件格式           .a 文件+头文件 或 .framework        .framework（包含动态二进制文件）
 链接方式           编译时直接复制到可执行文件             运行时动态加载，引用符号不复制代码
 应用体积           增大可执行文件体积                   可执行文件较小，但需附带动态库文件
 内存占用           高（多模块重复加载）                  低（仅加载一次，共享使用）
 加载时机           应用启动时随主程序加载                启动时需加载动态库（可能增加延迟）
 更新维护           需重新编译整个应用                   可独立更新（但受限于 iOS 沙盒机制）
 符号冲突处理        编译时报错（重复符号）                运行时覆盖（先加载的符号生效）
 Swift 支持        支持（需包含 Swift 模块文件）         原生支持（Swift 推荐使用动态库）
 资源管理           需手动管理资源（图片、xib 等）         可直接封装资源文件到 Framework 内部
 
 二、优缺点分析
 1. 静态库（Static Library）
 
 静态库
 优点：
 - 启动速度：代码在编译时链接，启动更快。
 - 兼容性：支持所有 iOS 版本，无系统限制。
 - 独立性：无需担心依赖问题，代码完全内聚。
 
 缺点：
 - 体积膨胀：多份相同静态库导致应用体积增大。
 - 更新困难：需重新编译整个应用才能更新代码。
 
 2. 动态库（Dynamic Framework）
 
 优点：
 - 体积优化：共享代码减少应用体积（系统级动态库如 UIKit）。
 - 模块化灵活：独立编译，适合大型工程。
 - 资源内置：可直接封装资源文件（如 Assets.car）。
 - Swift 友好：Swift 标准库依赖动态库。
 
 缺点：
 - 启动延迟：动态库加载可能拖慢启动时间（需控制数量）。
 - 沙盒限制：第三方动态库会被复制到 App 包内，无法真正共享。
 - 符号冲突风险：同名类/方法会被覆盖，导致不可控行为。
 - 最低系统要求：需 iOS 8+（Swift 动态库可能要求 iOS 12+）。
 
 典型场景：
 - 大型模块化 App（如电商 App 的支付、购物车模块）。
 - Swift 项目（因 Swift 标准库依赖动态库）。
 - 需要与 App Extensions 共享代码（如 Widget）。
 
 三、关键注意事项
 1、动态库的签名与嵌入
 第三方动态库必须签名并嵌入到 App 的 Frameworks 目录（通过 Xcode 的 Embed & Sign 配置）。
 
 2、动态库的启动优化
 使用 dyld 相关环境变量（如 DYLD_PRINT_STATISTICS）分析启动时间，避免过多动态库。
 
 3、资源访问方式
 动态库内的资源需通过 Bundle(for: MyClass.self) 获取：
 
 4、符号冲突解决方案
 为类/方法添加前缀（如 ABC_Logger）。
 使用 Swift 的访问控制（internal/private）减少暴露符号。
 
 四、动态库能解决符号冲突，但也存在问题
 两个动态库（.dylib/.framework）包含同名但不同版本的类，系统会默认加载第一个被加载到内存中的类版本，而另一个类会被忽略（不会共存），会导致代码不可控
 
 1、运行时仅保留一个类
 Objective-C 运行时不允许同一个类名（ClassName）存在多个实现。先加载的动态库中的类会“覆盖”后加载的同名类，后者会被忽略。
 
 2、行为不可控
 最终使用的类版本取决于动态库的加载顺序，若加载顺序不明确，可能导致随机性崩溃或逻辑错误。
 
 3、无版本隔离机制
 iOS 没有类似 Java/Swift 的命名空间（namespace）机制，Objective-C 的类名冲突直接导致符号覆盖。
 
 五、加载顺序的决定因素
 1、Xcode 的 Link Binary With Libraries 顺序
 Xcode 的链接顺序（Build Phases → Link Binary With Libraries）影响动态库的加载顺序，但不绝对。
 
 2、 依赖关系
 若 LibA 依赖 LibC，而 LibB 也依赖 LibC，可能触发更复杂的加载顺序。
 
 3、dyld 的行为
 iOS 动态链接器（dyld）的加载顺序由 Mach-O 文件的依赖关系决定，可通过 otool -L 查看依赖链：otool -L LibA.framework/LibA
 
 六、静态库如何增加包体积？
 
 1. 编译时完全复制
 机制：静态库（.a 或静态 Framework）在编译链接时，会被完整复制到最终的可执行文件（Mach-O）中。
 问题：如果多个模块（如主 App、Extension、Watch App）依赖同一个静态库，每个模块的可执行文件都会包含该静态库的完整代码副本，导致重复代码累积。
 
 2. 多目标重复引用
 例子：
 主 App 使用静态库 A（1MB）。
 Today Widget 扩展也使用静态库 A。
 最终包体积 = 主 App（1MB A 的副本） + Today Widget（1MB A 的副本） = 总增加 2MB。
 对比动态库：动态库只需在包中保留一份 .framework 文件（如 1MB），总增量仅 1MB。
 
 3、符号未优化
 Dead Code Stripping 失效：
 静态库编译时若未启用 -dead_strip 优化，链接器会将静态库所有代码（包括未被使用的部分）复制到可执行文件中。
 动态库由于运行时加载，链接时仅保留实际引用的符号。
 
 
 二、内联函数
 实现思想：
 内联函数的基本思想在于将每个函数调用以它的代码体来替换，很可能会增加整个目标代码的体积过分地使用内联所产生的程序
 会因为有太大的体积而导致可用空间不够。如果内联函数体非常短，编译器为这个函数体生成的代码就会真的比为函数调用生成
 的代码要小许多。如果是这种情况，内联这个函数将会确实带来更小的目标代码和更高的缓存命中率！
 
 内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处
 的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。
 
 三、静态函数
 C语言中使用静态函数的好处：
 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
 
 
 C程序一直由下列部分组成：
 1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；
 2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。
 3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
 4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。
 5）堆——动态存储分。
 
 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
 1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
 
 好处：
 定义全局静态变量的好处：
 <1>不会被其他文件所访问，修改
 <2>其他文件中可以使用相同名字的变量，不会发生冲突。
 
 局部静态变量
 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
 1）内存中的位置：静态存储区
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
 
 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，
 并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。
 
 3. 静态函数
 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。
 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
 定义静态函数的好处：
 <1> 其他文件中可以定义相同名字的函数，不会发生冲突
 <2> 静态函数不能被其他文件所用。 存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。
     auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出
     该程序块时撤销。关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期
    （static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性
     仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。
     由于static变量的以上特性，可实现一些特定功能。比如， 统计次数功能
 
 */
