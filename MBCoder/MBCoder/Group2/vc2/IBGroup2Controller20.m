//
//  IBGroup2Controller20.m
//  MBCoder
//
//  Created by Bowen on 2019/11/27.
//  Copyright © 2019 inke. All rights reserved.
//

#import "IBGroup2Controller20.h"

@interface IBGroup2Controller20 ()

@end

@implementation IBGroup2Controller20

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
}

/*
 参考：
 https://juejin.im/post/5c8756e6e51d456cda2e7ff1#heading-25
 https://mp.weixin.qq.com/s/Pqn3fk7ZAdSD_d9erDyy6g
 https://www.jianshu.com/p/210720f985a6
 
 设计模式（Design Pattern）
 是一套被反复使用、代码设计经验的总结
 使用设计模式的好处是：可重用代码、让代码更容易被他人理解、保证代码可靠性
 一般与编程语言无关，是一套比较成熟的编程思想

 设计模式可以分为三大类（创建型、结构型和行为型）
 
 创建型
 创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将模块中对象的创建和对象的使用分离。为了使结构更加清晰，
 外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。

 简单工厂模式（Simple Factory Pattern）
 工厂方法模式（Factory Method Pattern）
 抽象工厂模式（Abstract Factory Pattern）
 单例模式（Singleton Pattern）
 生成器模式（Builder Pattern）
 原型模式（Prototype Pattern）

 结构型
 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。
 结构型模式可以分为类结构型模式和对象结构型模式：
 1）类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
 2）对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。
   根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

 外观模式
 适配器模式
 桥接模式
 代理模式
 装饰者模式
 享元模式

 行为型
 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
 通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。

 职责链模式
 命令模式
 解释器模式
 迭代器模式
 中介者模式
 备忘录模式
 观察者模式
 状态模式
 策略模式
 模板方法模式
 访问者模式
 
 
 一、创建型模式：对象实例化的模式，用于解耦对象的实例化过程，主要用于描述如何创建对象
 
 1.单例模式(Singleton)：
 保证一个类仅有一个实例，并提供一个访问他的全局访问点。
 2.抽象工厂(Abstract Factory)：
 提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。
 3.工厂方法(Factory Method)：
 定义创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到其子类。
 4.建造者模式(Builder)：
 将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现
 5.原型模式(Prototype)：
 使用原型实例指定创建对象的种类，并通过复制这个原型创建新的对象。
 
 抽象工厂对比工厂方法：
 1）抽象工厂通过对象组合创建抽象产品；创建多系列产品；必须修改父类的接口才能支持新的产品。
 2）工厂方法通过类继承创建抽象产品；创建一种产品；自泪花创建者并重载工厂方法以创建新产品。
 

 二、行为型模式：类或对象之间如何交互，及划分责任和算法
 
 6.迭代器模式(Iterator)：
 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。
 7.观察者模式(Observer)：
 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都将得到通知并被自动更新。
 8.模板方法(Template Method)：
 定义一个操作中算法的骨架，而将一些不周延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变算法的结构。
 9.命令模式(Command)：
 将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。
 10.状态模式(State)：
 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。
 11.策略模式(Strategy)：
 定义一系列算法，把他们一个个封装起来，并且使他们可以相互替换。本模式使得算法可独立于使用它的客户而变化。
 12.职责链模式(China of Responsibility)：
 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将这些对象连城一条链，并沿着这条链传递请求，知道有一个对象处理它为止。
 13.中介者模式(Mediator)：
 用一个对象来封装一系列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
 14.访问者模式(Visitor)：
 表示一个作用于某对象结构中的各元素的操作。它让我们可以再不改变各元素的类的前提下定义作用于这些元素的新操作。
 15.解释器模式(Interpreter)：
 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
 16.备忘录模式(Memento)：
 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

 
 三、结构型模式：把类或对象结合在一起形成一个更大的结构
 
 17.组合模式(Composite)：
 将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。
 18.外观模式(Facade)：
 为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更易于使用。
 19.代理模式(Proxy)：
 为其他对象提供一种代理以控制对这个对象的访问。
 20.适配器模式(Adapter)：
 将一个类的接口转换成客户希望的另外一个接口，适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
 21.装饰模式(Decrator)：
 动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。
 22.桥接模式(Bridge)：
 将抽象部分与它的实现部分分离，使他们都可以独立的变化。
 23.享元模式(Flyweight)：
 运用共享技术有小弟支持大量细力度的对象。

*/


@end
