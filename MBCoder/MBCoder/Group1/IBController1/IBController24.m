//
//  IBController24.m
//  IBCoder1
//
//  Created by Bowen on 2018/5/18.
//  Copyright © 2018年 BowenCoder. All rights reserved.
//

#import "IBController24.h"

@interface IBController24 ()



@end

@implementation IBController24

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
    [self setupUI];
}

- (void)setupUI {
    
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    
}



@end

/*
 
 TCP/IP五层模型的协议分为：应用层、传输层、网络层、数据链路层和物理层

 TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)。
 UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快。
 
 TCP与UDP不同点
 报头不同
 特点不同
 协议不同
 
 一、TCP连接
 
 1、报头(最少占20个字节)
 源端口和目的端口字段
 TCP源端口（Source Port）：源计算机上的应用程序的端口号，占 16 位。
 TCP目的端口（Destination Port）：目标计算机的应用程序端口号，占 16 位。
 
 序列号字段
 TCP序列号（Sequence Number）：占 32 位。它表示本报文段所发送数据的第一个字节的编号。
 在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；
 如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。
 
 确认号字段
 TCP 确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。
 其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。
 
 数据偏移字段
 TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，
 占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。
 
 保留字段
 保留（Reserved）：占 4 位。为 TCP 将来的发展预留空间，目前必须全部为 0。
 
 标志位字段
 CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。
 ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。
 URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。
 ACK：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。
 PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。
 RST：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。
 SYN：同步序列号（Synchronize Sequence Numbers），在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。
 FIN：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，可以释放连接。
 
 窗口大小字段
 窗口大小（Window Size）：占 16 位。表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 TCP 的流量控制。
 
 TCP 校验和字段
 校验位（TCP Checksum）：占 16 位。它用于确认传输的数据是否有损坏。发送端基于数据内容校验生成一个数值，
 接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。
 如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。
 
 紧急指针字段
 紧急指针（Urgent Pointer）：仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。
 当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。
 
 可选项字段
 选项（Option）：长度不定，但长度必须是 32bits 的整数倍。
 
 2、特点
 1）面向连接
 在TCP/IP协议中，TCP协议提供可靠的面向连接的服务；三次握手（建立连接）和四次挥手（关闭连接）
 a、建立一个TCP连接时，需要客户端和服务器总共发送3个包及各自状态
 （1）第一次握手：建立连接时，客户端A发送SYN包[SYN=1,seq=x]到服务器B，并进入SYN_SEND状态，等待服务器B确认。
 （2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN，同时自己也发送一个SYN包，即SYN+ACK包[SYN=1,ACK=1,seq=y,ack=x+1]，此时服务器B进入SYN_RECV状态。
 （3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK[ACK=1,seq=x+1,ack=y+1]，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。 完成三次握手，客户端与服务器开始传送数据。
 
 总之、 三次握手完成后，客户端和服务器就建立了TCP连接。三次握手的目的是连接服务器指定端口，建立TCP连接，
 同步连接双方的序列号和确认号并交换TCP窗口大小信息。在socket编程中，客户端执行connect()时，将会触发三次握手。
 
 TCP三次握手的作用
 为了阻止历史的重复连接初始化造成的混乱问题，防止使用TCP协议通信的双方建立了错误的连接
 帮助通信双方获取初始化序列号，保证数据包传输的不重不丢和传输顺序
 
 TCP 为什么三次握手而不是两次握手
 两次握手无法避免历史错误连接的初始化，浪费接收方的资源；
 两次握手发送方起始序列号能被确认，接受方的序列号得不到确认
 
 三次握手失败了会怎么样？
 Client在发送SYN之后没有收到ACK消息，Client会进行重传，第一次重传时间5.5-6s之间，第二次重传会是24s，不成功还会继续尝试，
 伯克利系统在超过75s之后，如果还是不成功，会放弃尝试连接

 b、四次挥手关闭TCP连接的各状态
 （1）首先A B端的TCP进程都处于连接状态（established），当A的应用程序传送完报文段，就会去主动关闭连接。
     A会停止发送报文段（但是还会接收），并向B发送[FIN = 1,seq=u]数据，之后进入FIN-WAIT-1状态；
 （2）B接收到A发送的请求之后，会通知应用进程，A已经不再发送数据，同时B会向A发送ACK确认数据[ACK=1,seq=v,ack=u+1 ]，B进入CLOSE-WAIT状态，A接收到B发送的数据之后，A进入FIN-WAIT-2状态；此时A到B方的连接已经关闭了（即半连接状态）。
 （3）当B的应用进程发现自己也没有数据需要传送，B应用进程就会发出被动关闭的请求，B此时向A发送[FIN=1,ACK=1,seq=w,ack=u+1]数据，并且进入LAST-ACK状态；
 （4）A接收到B发送的数据之后，向B发送ACK确认数据[ACK =1,seq=u+1,ack=w+1]，
     进入TIME-WAIT状态，等待2MSL之后正常关闭连接进入CLOSED状态；B接收到A发送的确认之后进入CLOSED状态。B到A方的连接关闭！至此，TCP连接才真正全部关闭！

 2）可靠传输（序列号 确认应答 超时重传 拥塞控制）
 主要说：拥塞控制
 每次发送数据包的时候, 将拥塞窗口和接收端主机反馈的窗口大小做比较, 取较小的值作为实际发送的窗口。
 拥塞控制, 归根结底是TCP协议想尽可能快的把数据传输给对方, 但是又要避免给网络造成太大压力的折中方案。
 
 发送方维护一个拥塞窗口（cwnd）的状态变量，根据网络状态动态变化
    拥塞窗口维护原则：网络没有出现拥塞，窗口再增大一些。出现拥塞，窗口缩小一些
    网络拥塞判断依据：发生重传
 发送方把拥塞窗口作为发送窗口（swnd），即cwnd = swnd
 维护一个慢开始门限ssthresh状态变量，
 
 TCP的四种拥塞控制算法
 慢开始：
 每次收到该确认报文后，当前发送方拥塞窗口cwnd的值*2
 当前的拥塞窗口cwnd的值已经等于慢开始门限值（ssthresh），之后改用拥塞避免算法。
 拥塞避免：
 当 cwnd 增长到 sshthresh 时，就会进入“拥塞避免算法”。拥塞避免算法下 cwnd 成线性增长，
 即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样就可以避免拥塞窗口快速增长的问题。
 快重传
 快速重传算法主要用于丢包检测，以便能更快重传数据包，更早的调整拥塞状态机状态，从而达到持续升窗的目的
 快恢复
 当检测到丢包时，TCP 会触发快速重传并进入降窗状态。该状态下 cwnd 会通过快速恢复算法降至一个合理值
 
 提高传输效率：滑动窗口、流量控制、延迟应答、捎带应答
 滑动窗口机制
 1) 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值.
 2) 发送窗口内字段的时候, 不需要等待任何ACK, 直接发送;
 3) 收到第一个ACK后, 滑动窗口向后移动, 继续发送下一个窗口字段的数据; 依次类推;
 4) 操作系统内核为了维护这个滑动窗口, 需要开辟发送缓冲区来记录当前还有哪些数据没有应答; 只有确认应答过的数据, 才能从缓冲区删掉;
 5) 窗口越大, 则网络的吞吐率就越高
 
 流量控制
 1) 接收端将自己可以接收的缓冲区大小放入TCP首部中的 "窗口大小" 字段, 通过ACK端通知发送端;
 2) 窗口大小字段越大, 说明网络的吞吐量越⾼高;
 3) 接收端一旦发现自己的缓冲区快满了, 就会将窗口大小设置成一个更小的值通知给发送端;
 4) 发送端接受到这个窗口之后, 就会减慢自己的发送速度;
 5) 如果接收端缓冲区满了, 就会将窗口置为0; 这时发送⽅方不再发送数据, 但是需要定期发送一个窗口

 延迟应答
 如果接收数据的主机立刻返回ACK应答, 这时候返回的窗口可能比较小.
 窗口越大, 网络吞吐量就越大, 传输效率就越高. 我们的目标是在保证网络不拥塞的情况下尽量提高传输效率;

 捎带应答
 在延迟应答的基础上, 我们发现, 很多情况下, 客户端服务器在应用层也是 “一发一收” 的.
 意味着客户端给服务器说了 “How are you”, 服务器也会给客户端回一个 “Fine, thank you”;
 那么这个时候ACK就可以搭顺风车, 和服务器回应的 “Fine, thank you” 一起回给客户端。
 
 3）面向字节流：
 创建一个TCP的socket, 同时在内核中创建一个发送缓冲区和一个接收缓冲区；
 
 3、协议
 HTTP
 HTTPS
 SSH
 Telnet
 FTP
 SMTP
 
 4、为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
   这是因为服务端的LISTEN状态下的SOCKET当收到客户端的SYN报文的建立连接请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在
 一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你
 可以未必会马上会关闭SOCKET，也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报
 文和FIN报文多数情况下都是分开发送的。
 
 5、TCP粘包，拆包及解决方法
 
 1）TCP为什么会粘包
 首先要明确, 粘包问题中的 “包” , 是指的应用层的数据包；
 在TCP的协议头中, 没有如同UDP一样的 “报文长度” 这样的字段, 但是有一个序号这样的字段；
 站在传输层的角度, TCP是一个一个报文过来的，按照序号排好序放在缓冲区中；
 站在应用层的角度, 看到的只是一串连续的字节数据，不知道从哪个部分开始到哪个部分是一个完整的应用层数据包。
 
 2）UDP会粘包吗
 可能会
 UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，
 因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。
 注意点：但是IPv4并不强制执行，也就是说UDP无法保证数据的完整性，但IPV6是强制要求使用的。
 
 3）粘包、拆包发生原因
 发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，
 1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
 2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
 3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
 
 4）粘包、拆包解决办法
 1、发送端给数据包添加包首部，首部中包含数据包的长度，接收端在接收到数据后，通过读取包首部的长度字段，便知每个数据包的长度。
 2、发送端将数据包封装为固定长度（不够的可以通过补0填充），接收端每次从接收缓冲区中读取固定长度的数据，把每个数据包拆分开来。
 3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

 二、HTTP连接
    HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。
 从建立连接到关闭连接的过程称为“一次连接”。请求-响应是它的最大特点（请求行 请求头 请求体 响应状态行）
 
 1、HTTPS原理
 证书验证阶段：
 前端发起 HTTPS 请求。
 服务端返回 HTTPS 证书。
 前端验证证书是否合法，如果不合法则提示告警。

 数据传输阶段：
 当前端证书验证合法后，在本地生成随机数。
 通过公钥加密随机数，并把加密后的随机数传输到服务端。
 服务端通过私钥对随机数进行解密。
 服务端通过前端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。
 
 2、为什么数据传输是用对称加密?
 a、非对称加密的加解密效率是非常低的，而 HTTP 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。
 b、在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密
 
 3、中间人攻击
 过程原理如下：
 本地请求被劫持(如 DNS 劫持等)，所有请求均发送到中间人的服务器。
 中间人服务器返回中间人自己的证书。
 客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。
 中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密。
 中间人以客户端的请求内容再向正规网站发起请求。
 因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据。
 中间人凭借与正规网站建立的对称加密算法对内容进行解密。
 中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输。
 客户端通过与中间人建立的对称加密算法对返回结果数据进行解密。
 
 三、Socket
    socket（套接字）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的
 IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
    建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。套接字之间的连
 接过程分为三个步骤：服务器监听，客户端请求，连接确认。
 Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接,UDP连接同理。


四、彼此区别
 1、TCP连接与HTTP连接的区别
    HTTP是基于TCP的，客户端往服务端发送一个HTTP请求时第一步就是要建立与服务端的TCP连接，也就是先三次握手，“你好，你好，你好”。
 从HTTP 1.1开始支持持久连接，也就是一次TCP连接可以发送多次的HTTP请求。
 小总结：HTTP基于TCP
 
 2、TCP连接与Socket连接的区别
    socket层只是在TCP/UDP传输层上做的一个抽象接口层，因此一个socket连接可以基于连接，也有可能基于UDP。基于TCP协议的socket连接同样需
 要通过三次握手建立连接，是可靠的；基于UDP协议的socket连接不需要建立连接的过程，不过对方能不能收到都会发送过去，是不可靠的，大多数的即时
 通讯IM都是后者。
 小总结：Socket也基于TCP
 
 3、HTTP连接与Socket连接的区别
   通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际应用中，客户端到
 服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。
   而HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
 
 五、UDP介绍
 1、UDP数据段（报文头格式）
 源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。
 目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。
 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。
 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。
 
总结，UDP数据报最大长度64K（包含UDP首部），最少长度是8k(报文头长度占8个字节)，
如果数据长度超过64K就需要在应用层手动分包，UDP无法保证包序，需要在应用层进行编号。
 
 2、特点
 无连接：知道对端的IP和端口号就直接进行传输, 不需要建立连接。
 不可靠：没有确认机制, 没有重传机制; 如果因为网络故障该段无法发到对方, UDP协议层也不会给应用层返回任何错误信息。
 面向数据报：不能够灵活的控制读写数据的次数和数量，应用层交给UDP多长的报文, UDP原样发送, 既不会拆分, 也不会合并。
 数据收不够灵活，但是能够明确区分两个数据包，避免粘包问题。

 3、协议：
 NFS: 网络文件系统
 TFTP: 简单文件传输协议
 DHCP: 动态主机配置协议
 BOOTP: 启动协议(用于无盘设备启动)
 DNS: 域名解析协议
 
 4、UDP优势
 ①开销更小
 TCP为了保证其可靠性，首部包含20字节，以及40字节的可选项，UDP首部只有8字节
 ②速度更快
 UDP发送数据之前没有TCP的连接建立过程；
 TCP提供了过多的保护，在及时性上做了很多的妥协，比如：控制微包，延时ACK，流量控制，超时重传等，这些设计严重影响了Tcp的速度和及时性
 
 5、UDP传输过程中存在的主要问题：
 ①丢失和乱序：因为UDP不提供ACK、序列号等机制，所以是没有办法知道是否有报文丢失以及接收方到达等报文顺序是否和发送方发送的报文数据一样；
 ②差错：对于差错问题则是可以通过校验和等检测到，但是不提供差错纠正；
 ③数据完整性，UDP协议头部虽然有16位的校验和，但是IPv4并不强制执行，也就是说UDP无法抱枕数据的完整性
 
 6、UDP如何解决其传输过程中的问题：
 在UDP数据包头再加一段包头，从而定义为RUDP，答案是肯定的。首先思考RUDP需要解决哪些问题，然后根据问题加上必要的包头字段。
 1. 数据完整性 –> 加上一个16或者32位的CRC验证字段
 2. 乱序 –> 加上一个数据包序列号SEQ
 3. 丢包 –> 需要确认和重传机制
 4. 协议字段 –> protol 字段，标识当前使用协议，过滤非法包使用
 
 综合以上字段，我们的RUDP就可以简单实现成如下：
 1byte：protol 字段
 2byte：CRC验证
 4byte：SEQ，数据包序列号
 1byte：isAck确认回包
 
 7、RUDP（Reliable UDP）：
 RUDP，可靠UDP，实现了UDP的一些可靠性
 参考链接：http://www.sohu.com/a/208825991_467759
 
 六、一次完整的HTTP请求过程
 1、DNS解析（缓存->hosts文件->DNS服务器）
    DNS优化两个方面：DNS缓存、DNS负载均衡
 2、HTTP工作流程
 第一步（连接）：建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接
 第二步（请求）：客户端向服务端发起HTTP请求，请求报文（请求行(GET/POST)、请求头部(User-Agent)、空行(分割数据)和请求数据）
 第三步（应答）：服务器做出响应，响应报文主要由状态行(协议版本，状态码)、响应头（客户端如何处理数据）、空行以及响应数据
 第四步（关闭）：服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，
       在下次请求时可以继续使用这次的连接
 
 七、服务响应快慢分析
 1、排除自身网络问题
 2、查看服务日志系统（异常）
 3、查看服务器各项参数（cpu、内存、网卡、磁盘）
 4、数据库分析
 
 八、状态码
 1**    信息，服务器收到请求，需要请求者继续执行操作
 2**    成功，操作被成功接收并处理
 3**    重定向，需要进一步的操作以完成请求
 4**    客户端错误，请求包含语法错误或无法完成请求
 5**    服务器错误，服务器在处理请求的过程中发生了错误
 
 */
