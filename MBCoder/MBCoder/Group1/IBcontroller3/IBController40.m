//
//  IBController40.m
//  IBCoder1
//
//  Created by Bowen on 2018/7/27.
//  Copyright © 2018年 BowenCoder. All rights reserved.
//

#import "IBController40.h"
#import "ReactiveObjC.h"
@interface IBController40 ()

@end

@implementation IBController40

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor whiteColor];
}

- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event {
    
}

@end

/*
 一、动态库和静态库的区别
 
 库从本质上来说是一种可执行代码的二进制格式，可以被载入内存中执行。库分静态库和动态库两种。
 
 1、iOS开发中静态库和动态库区别:
 静态库和动态库是相对编译期和运行期的：
 静态库在程序编译时会被链接到目标代码中，程序运行时将不再需要改静态库；
 动态库在程序编译时并不会被链接到目标代码中，在程序启动后用动态加载，然后再决议符号。
 
 静态库
 优点：
 1）目标程序没有外部依赖，直接就可以运行
 2）效率比动态库高
 3）模块化，分工合作
 4）避免少量改动经常导致大量的重复编译连接
 5）也可以重用，注意不是共享使用
 缺点：
 1）会使用目标程序的体积增大
 
 动态库：
 优点：
 1）不需要拷贝到目标程序中，不会影响目标程序的体积。
 2）同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。
 3）编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。实现动态更新
 缺点：
 1）动态载入会带来一部分性能损失(可以忽略不计）
 2）动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux lib not found 错误）

 2、iOS的动态库（被阉割的动态库）
 
 原因：
 1）iOS平台上规定不允许存在动态库，并且所有的 IPA 都需要经过Apple的私钥加密后才能用，
 基本你用了动态库也会因为签名不对无法加载，(越狱和非 APP store 除外)。于是就把开发者自己开发动态库成为了天方夜谭。

 2）iOS8之前因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，并且iOS是单进程的，也就是某一时刻只有一个进程在运行，那么你写个共享库，给谁共享呢。
 同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，综上所以上动态库也就没有存在的必要了。
 
 3）后来iOS8之后，iOS有了App Extesion特性，而且Swift也诞生了。由于iOS主App需要和Extension共享代码，Swift语言机制也需要动态库，
 于是苹果后来提出了Embedded Framework，这种动态库允许APP和APP Extension共享代码，但是这份动态库的生命被限定在一个APP进程内。简单点可以理解为被阉割的动态库。
 
 3、编译两个重要的过程：编译和链接
 编译可以理解为将源代码编译为目标文件，
 链接可以理解为将各种目标文件上加一些第三方库、并且和系统库链接起来为可执行文件。
 因为某个目标文件的符号（可以理解为变化、函数）可能来至其他目标文件，链接最为主要的就是决议符号的地址。
 
 在决议符号的时候有如下规则：
 1）若符号来自静态库(本质就是.o 的集合包)或 .o，将其纳入链接产物，并确定符号地址。常见的符号冲突就出现在这一步。
 2）若符号来自动态库，打个标记，等启动的时候再说—交给dyld去加载和链接符号。
 也就是把链接的过程推迟到运行时再进行，上面讲到的静态库符号冲突就可以推迟到运行时在解决，
 而具体怎么解决由系统去决定。如果这两个符号表示的意思是一样（比如函数符号冲突但是函数的实现是一样的）的就没有问题

 4、静态库和动态库依赖关系
 1）静态库互相依赖，制作静态库的时候只需要有被依赖的静态库头文件在就能编译出来。但是这就意味者你要收到告诉使用者你的依赖关系。
 2）静态库依赖动态库，静态库制作的时候也需要动态库参与链接，但是符号的决议交给dyld来做。
 3）动态库依赖动态库，两个动态库是相互隔离的具有隔离性。在制作的动态库的时候需要被依赖动态库参与链接，最终具体的符号决议交给dyld来做。
 4）动态库依赖静态库，这种情况就有点特殊。首先我们设想动态库编译的时候需要静态库参与编译，但是静态库交由dyld来做符号决议，这和我们前面说的就矛盾了啊。
 静态库本质是一堆.o 的打包体，首先并不是二进制可执行文件，再者你无法保证主程序把静态库参与链接共同生成二进制可执行文件
 第四种情况目前编译器解决办法：
 首先我无法保证主程序是否包含静态库，再者静态库也无法被dyld加载，那么我直接把你静态库的.o 偷过来，共同组成一个新的二进制。也被称做吸附性。
 
 5、利用动态库解决相关问题
 1）处理多个动态库依赖一个静态库问题
 通过前面我们知道可执文件（主程序或者动态库）在构建的链接阶段，遇到静态库，吸附进来；遇到动态库，打标记，彼此保持独立。
 正因为动态库是保持独立的，那么我们可以自定义一个动态库把依赖的静态库吸附进来。对外整体呈现的是动态库特性。
 其他的组件依赖我们自定义的动态库，由于隔离性的存在，不会出现问题

 2）利用动态库处理静态库与静态库的符号冲突问题
 在打包IPA的时候，最终静态库会被连接到最终的那个可执行文件中。所以如果多个静态库拥有了相同的符号必定会产生符号冲突。

 前面讲过可以把动态库看成一个独立的没有main函数入口的可执行文件，在iOS打包中直接copy到应用程序.app目录下的Frameworks目录。
 既然是可执行文件那么内部编译连接过程已经完成了，要处理的连接也只有在加载的时候由操作系统的dyld自动load + link。
 所以最终系统在加载动态库的时候和静态库的符号根本没有丝毫关系，进而避免了链接时产生的符号冲突。
 
 二、内联函数
 实现思想：
 内联函数的基本思想在于将每个函数调用以它的代码体来替换，很可能会增加整个目标代码的体积过分地使用内联所产生的程序
 会因为有太大的体积而导致可用空间不够。如果内联函数体非常短，编译器为这个函数体生成的代码就会真的比为函数调用生成
 的代码要小许多。如果是这种情况，内联这个函数将会确实带来更小的目标代码和更高的缓存命中率！
 
 内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处
 的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。
 
 三、静态函数
 C语言中使用静态函数的好处：
 静态函数会被自动分配在一个一直使用的存储区，直到退出应用程序实例，避免了调用函数时压栈出栈，速度快很多。
 
 
 C程序一直由下列部分组成：
 1）正文段——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；
 2）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。
 3）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为0。
 4）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。
 5）堆——动态存储分。
 
 在全局变量之前加上关键字static，全局变量就被定义成为一个全局静态变量。
 1）内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：全局静态变量在声明他的文件之外是不可见的。准确地讲从定义之处开始到文件结尾。
 
 好处：
 定义全局静态变量的好处：
 <1>不会被其他文件所访问，修改
 <2>其他文件中可以使用相同名字的变量，不会发生冲突。
 
 局部静态变量
 在局部变量之前加上关键字static，局部变量就被定义成为一个局部静态变量。
 1）内存中的位置：静态存储区
 2）初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非他被显示初始化）
 3）作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域随之结束。
 
 注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，
 并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。
 当static用来修饰全局变量的时候，它就改变了全局变量的作用域（在声明他的文件之外是不可见的），但是没有改变它的存放位置，还是在静态存储区中。
 
 3. 静态函数
 在函数的返回类型前加上关键字static，函数就被定义成为静态函数。
 函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
 定义静态函数的好处：
 <1> 其他文件中可以定义相同名字的函数，不会发生冲突
 <2> 静态函数不能被其他文件所用。 存储说明符auto，register，extern，static，对应两种存储期：自动存储期和静态存储期。
     auto和register对应自动存储期。具有自动存储期的变量在进入声明该变量的程序块时被建立，它在该程序块活动时存在，退出
     该程序块时撤销。关键字extern和static用来说明具有静态存储期的变量和函数。用static声明的局部变量具有静态存储持续期
    （static storage duration），或静态范围（static extent）。虽然他的值在函数调用之间保持有效，但是其名字的可视性
     仍限制在其局部域内。静态局部对象在程序执行到该对象的声明处时被首次初始化。
     由于static变量的以上特性，可实现一些特定功能。比如， 统计次数功能
 
 */
